# Implementation Plan: Adaptive Signal Loop

**Branch**: `015-adaptive-signals` | **Date**: 2025-12-28 | **Spec**: [spec.md](./spec.md)
**Input**: Feature specification from `/specs/015-adaptive-signals/spec.md`

## Summary

Real-time self-adapting liquidation signals with Redis pub/sub integration to Nautilus (trading) and UTXOracle (dashboard). Includes P&L feedback loop for weight adjustment based on rolling accuracy metrics.

**Key Components**:
1. Signal Publisher → Redis `liquidation:signals:{symbol}`
2. Feedback Consumer ← Redis `liquidation:feedback:{symbol}`
3. Adaptive Engine → Weight adjustment based on regime detection

## Technical Context

**Language/Version**: Python 3.11+
**Primary Dependencies**: FastAPI, DuckDB, Redis (redis-py), Pydantic
**Storage**: DuckDB for analytics, Redis for real-time pub/sub
**Testing**: pytest with TDD guard
**Target Platform**: Linux server
**Project Type**: single
**Performance Goals**: Signal publish <10ms, Feedback processing <50ms
**Constraints**: Redis connection required, Nautilus/UTXOracle integration
**Scale/Scope**: Real-time signals every 15min, rolling metrics (1h, 24h, 7d)

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

| Gate | Status | Notes |
|------|--------|-------|
| **Mathematical Correctness** | ✅ PASS | Weight adjustment uses validated backtest metrics (F1=80.93%) |
| **Test-Driven Development** | ✅ PASS | TDD for signal/feedback modules |
| **Exchange Compatibility** | ✅ PASS | Leverages existing validated pipeline (Gate 1: 77.8%) |
| **Performance Efficiency** | ✅ PASS | <10ms publish target, Redis pub/sub is fast |
| **Data Integrity** | ✅ PASS | Feedback stored in DuckDB with timestamps |
| **Graceful Degradation** | ✅ PASS | Fallback to default weights if Redis unavailable |
| **Progressive Enhancement** | ✅ PASS | Can run without Nautilus/UTXOracle initially |
| **Documentation Completeness** | ✅ PASS | Signal format in plan.md, API in T035 (README update) |

**Gate Assessment**: All MUST gates pass. No violations.

## Project Structure

### Documentation (this feature)

```
specs/015-adaptive-signals/
├── plan.md              # This file
├── research.md          # Redis patterns, weight algorithms
├── data-model.md        # Signal/Feedback schemas
├── quickstart.md        # Redis setup, test commands
├── contracts/           # Signal format, feedback format
└── tasks.md             # Generated by /speckit.tasks
```

### Source Code (repository root)

```
src/liquidationheatmap/
├── signals/                      # NEW: Adaptive signals module
│   ├── __init__.py
│   ├── publisher.py              # Redis signal publisher
│   ├── feedback.py               # P&L feedback consumer
│   └── adaptive.py               # Weight adjustment engine
├── models/
│   └── time_evolving_heatmap.py  # Existing (source of signals)
├── services/
│   └── db_service.py             # Existing
└── api/
    └── main.py                   # Add signal endpoints

tests/
├── unit/
│   └── test_adaptive_signals.py  # Unit tests for signals module
├── integration/
│   └── test_redis_pubsub.py      # Redis integration tests
└── contract/
    └── test_signal_format.py     # Signal contract tests
```

**Structure Decision**: Single project. New `signals/` module under existing `src/liquidationheatmap/`.

## Complexity Tracking

*No Constitution violations - complexity tracking not required.*

---

## Phase 0: Research Summary

### Research Questions

1. **Redis Pub/Sub Pattern**: Best practices for financial signal publishing?
2. **Weight Adjustment Algorithm**: How to adapt based on P&L feedback?
3. **Regime Detection**: How to detect trending/ranging/volatile markets?
4. **Rollback Strategy**: How to revert to default weights if adaptation fails?

### Answers (from spec + domain knowledge)

| Question | Answer | Source |
|----------|--------|--------|
| Redis Pattern | Pub/sub with JSON serialization, channel per symbol | Industry standard |
| Weight Adjustment | Exponential moving average of hit rates | Backtest framework |
| Regime Detection | Volatility bands + trend slope | ATR + SMA crossover |
| Rollback | Store default weights, revert if hit_rate < 0.50 | Constitution §6 |

---

## Phase 1: Design Artifacts

### Data Model

**Signal Schema** (`liquidation:signals:{symbol}`):
```python
from decimal import Decimal  # Use Decimal128 precision per Constitution §1

class LiquidationSignal(BaseModel):
    symbol: str              # e.g., "BTCUSDT"
    price: Decimal           # Liquidation price level (Decimal128)
    side: Literal["long", "short"]
    confidence: float        # 0.0-1.0, from heatmap density
    timestamp: datetime
    source: str = "liquidationheatmap"
```

**Feedback Schema** (`liquidation:feedback:{symbol}`):
```python
class TradeFeedback(BaseModel):
    symbol: str
    signal_id: str           # Reference to original signal
    entry_price: Decimal     # Decimal128 precision
    exit_price: Decimal      # Decimal128 precision
    pnl: Decimal             # Realized P&L (Decimal128)
    timestamp: datetime
    source: str              # "nautilus" or "manual"
```

### API Contracts

**GET /signals/status**
```json
{
  "connected": true,
  "last_publish": "2025-12-28T10:30:00Z",
  "signals_published_24h": 96,
  "feedback_received_24h": 12
}
```

**GET /signals/metrics?symbol=BTCUSDT&window=24h**
```json
{
  "symbol": "BTCUSDT",
  "window": "24h",
  "hit_rate": 0.75,
  "total_signals": 96,
  "feedback_count": 12,
  "avg_pnl": 0.023
}
```

### Quickstart

```bash
# 1. Start Redis (if not running)
redis-server --daemonize yes

# 2. Test Redis connection
redis-cli ping  # Should return PONG

# 3. Subscribe to signals (terminal 1)
redis-cli SUBSCRIBE liquidation:signals:BTCUSDT

# 4. Publish test signal (terminal 2)
uv run python -c "
from src.liquidationheatmap.signals.publisher import SignalPublisher
pub = SignalPublisher()
pub.publish_signal('BTCUSDT', 95000.0, 'long', 0.85)
"

# 5. Run signal publisher (production)
uv run python -m src.liquidationheatmap.signals.publisher --symbol BTCUSDT

# 6. Run feedback consumer (production)
uv run python -m src.liquidationheatmap.signals.feedback --symbol BTCUSDT
```

---

## Implementation Phases (from spec)

| Phase | Component | Key Deliverable |
|-------|-----------|-----------------|
| **Phase 1** | Signal Publisher | `signals/publisher.py` - Redis pub |
| **Phase 2** | Feedback Consumer | `signals/feedback.py` - Redis sub + DuckDB |
| **Phase 3** | Adaptive Engine | `signals/adaptive.py` - Weight adjustment |
| **Phase 4** | API Integration | Endpoints + monitoring |
| **Phase 5** | Nautilus/UTXOracle | External integration |

## Success Criteria

### P0 - Must Have (Blocking PR Merge)
- [ ] Signal Publisher publishes to Redis on heatmap update
- [ ] Signal format matches contract schema
- [ ] Unit tests pass with mocked Redis
- [ ] Integration test with real Redis

### P1 - Should Have
- [ ] Feedback Consumer stores P&L in DuckDB
- [ ] Rolling accuracy metrics (1h, 24h, 7d)
- [ ] Weight adjustment based on feedback

### P2 - Nice to Have (Future Work)
- [ ] Nautilus strategy integration
- [ ] UTXOracle dashboard widget
- [ ] Regime detection (trending/ranging/volatile)

## Rollback Plan

1. **Disable signal publishing**: Set `SIGNALS_ENABLED=false` in config
2. **Revert to default weights**: Delete `adaptive_weights` table rows
3. **Existing pipeline unaffected**: Heatmap continues without signals

---

**Plan Status**: ✅ Complete - Ready for `/speckit.tasks` command
