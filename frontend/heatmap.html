<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BTC/USDT Liquidation Heatmap</title>
    <script src="https://cdn.plot.ly/plotly-2.26.0.min.js"></script>
    <link rel="stylesheet" href="styles.css">
    <style>
        /* T038: Smooth CSS transitions for cluster zones (60 FPS, <300ms) */
        .cluster-zone {
            transition: opacity 250ms ease-out, transform 250ms ease-out;
            will-change: opacity, transform;
        }
        .cluster-zone-enter {
            opacity: 0;
            transform: scaleY(0.95);
        }
        .cluster-zone-exit {
            opacity: 0;
            transform: scaleY(1.05);
        }
        /* T070-T076: Exchange selector and health badges */
        .exchange-selector {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            margin-left: 15px;
        }
        .exchange-selector label {
            color: #c9d1d9;
            font-size: 14px;
        }
        .exchange-selector select {
            background: #21262d;
            color: #c9d1d9;
            border: 1px solid #30363d;
            border-radius: 6px;
            padding: 6px 10px;
            font-size: 14px;
            cursor: pointer;
        }
        .exchange-selector select:focus {
            outline: none;
            border-color: #58a6ff;
        }
        .exchange-health-badges {
            display: flex;
            gap: 12px;
            margin-top: 10px;
            flex-wrap: wrap;
        }
        .exchange-badge {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            border-radius: 16px;
            font-size: 13px;
            font-weight: 500;
            transition: all 0.2s ease;
        }
        .exchange-badge.binance {
            background: rgba(240, 185, 11, 0.15);
            color: #F0B90B;
            border: 1px solid rgba(240, 185, 11, 0.3);
        }
        .exchange-badge.hyperliquid {
            background: rgba(155, 89, 182, 0.15);
            color: #9B59B6;
            border: 1px solid rgba(155, 89, 182, 0.3);
        }
        .exchange-badge.bybit {
            background: rgba(241, 145, 70, 0.15);
            color: #F19146;
            border: 1px solid rgba(241, 145, 70, 0.3);
        }
        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            display: inline-block;
        }
        .status-dot.connected {
            background: #2ea043;
            box-shadow: 0 0 4px rgba(46, 160, 67, 0.5);
        }
        .status-dot.disconnected {
            background: #da3633;
            box-shadow: 0 0 4px rgba(218, 54, 51, 0.5);
        }
        .status-dot.degraded {
            background: #d29922;
            box-shadow: 0 0 4px rgba(210, 153, 34, 0.5);
        }
        /* T072: Loading indicator */
        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(13, 17, 23, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }
        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 3px solid #30363d;
            border-top-color: #58a6ff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        #heatmap-container {
            position: relative;
        }
        .exchange-legend {
            display: flex;
            gap: 16px;
            margin-top: 8px;
            padding: 8px 12px;
            background: #161b22;
            border-radius: 6px;
            font-size: 13px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
            color: #c9d1d9;
        }
        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <h1>BTC/USDT Liquidation Heatmap</h1>

    <!-- T073: Exchange health badges -->
    <div class="exchange-health-badges" id="exchangeHealthBadges">
        <div class="exchange-badge binance">
            <span class="status-dot disconnected" id="binance-status"></span>
            <span>Binance</span>
            <span id="binance-heartbeat" style="font-size: 11px; opacity: 0.7;"></span>
        </div>
        <div class="exchange-badge hyperliquid">
            <span class="status-dot disconnected" id="hyperliquid-status"></span>
            <span>Hyperliquid</span>
            <span id="hyperliquid-heartbeat" style="font-size: 11px; opacity: 0.7;"></span>
        </div>
        <div class="exchange-badge bybit">
            <span class="status-dot disconnected" id="bybit-status"></span>
            <span>Bybit</span>
            <span id="bybit-heartbeat" style="font-size: 11px; opacity: 0.7;"></span>
        </div>
    </div>

    <div class="controls">
        <button onclick="loadHeatmap()">Load Heatmap</button>
        <button id="clusterToggle" onclick="toggleClusters()" style="margin-left: 10px;">Show Clusters</button>

        <!-- T070: Exchange selector dropdown -->
        <div class="exchange-selector">
            <label for="exchangeSelect">Exchange:</label>
            <select id="exchangeSelect" onchange="onExchangeChange()">
                <option value="all">All Exchanges</option>
                <option value="binance" selected>Binance</option>
                <option value="hyperliquid">Hyperliquid</option>
                <option value="binance,hyperliquid">Binance + Hyperliquid</option>
            </select>
        </div>
    </div>

    <!-- T079: Exchange color legend -->
    <div class="exchange-legend" id="exchangeLegend" style="display: none;">
        <div class="legend-item">
            <span class="legend-color" style="background: #F0B90B;"></span>
            <span>Binance</span>
        </div>
        <div class="legend-item">
            <span class="legend-color" style="background: #9B59B6;"></span>
            <span>Hyperliquid</span>
        </div>
        <div class="legend-item">
            <span class="legend-color" style="background: #F19146;"></span>
            <span>Bybit</span>
        </div>
    </div>

    <!-- T072: Heatmap container with loading overlay -->
    <div id="heatmap-container">
        <div id="loading" class="loading-overlay" style="display: none;">
            <div class="loading-spinner"></div>
        </div>
        <div id="heatmap"></div>
    </div>
    <div id="clusterInfo" style="margin-top: 20px; padding: 10px; background: #161b22; border-radius: 6px; display: none;">
        <h3>Cluster Details</h3>
        <div id="clusterDetails"></div>
    </div>

    <script>
        // T076: Exchange color constants
        const EXCHANGE_COLORS = {
            binance: '#F0B90B',      // Binance yellow
            hyperliquid: '#9B59B6',  // Hyperliquid purple
            bybit: '#F19146',        // Bybit orange
            all: '#3498db'           // Default blue
        };

        // T074: Health badge polling interval (30 seconds)
        const HEALTH_POLL_INTERVAL_MS = 30000;
        let healthPollInterval = null;

        // T071: Handle exchange selection change
        function onExchangeChange() {
            loadHeatmap();
        }

        // T072: Show/hide loading indicator
        function showLoading() {
            document.getElementById('loading').style.display = 'flex';
        }
        function hideLoading() {
            document.getElementById('loading').style.display = 'none';
        }

        // Get selected exchanges from dropdown
        function getSelectedExchanges() {
            const select = document.getElementById('exchangeSelect');
            return select.value;
        }

        async function loadHeatmap() {
            showLoading();  // T072
            try {
                const exchanges = getSelectedExchanges();
                const exchangeParam = exchanges !== 'all' ? `&exchanges=${exchanges}` : '';
                const response = await fetch(`http://localhost:8000/liquidations/heatmap?symbol=BTCUSDT&model=binance_standard${exchangeParam}`);
                const data = await response.json();

                if (!data.data || data.data.length === 0) {
                    hideLoading();
                    alert('No heatmap data available. Run: python scripts/generate_heatmap_cache.py');
                    return;
                }

                // Extract unique times and prices
                const times = [...new Set(data.data.map(d => d.time))].sort();
                const prices = [...new Set(data.data.map(d => d.price_bucket))].sort((a, b) => a - b);

                // T077/T078: Check if data has exchange breakdown
                const hasExchangeData = data.data.some(d => d.exchange);
                const selectedExchanges = exchanges === 'all' ? ['binance', 'hyperliquid'] : exchanges.split(',');

                let traces = [];

                if (hasExchangeData && selectedExchanges.length > 1) {
                    // T078: Create stacked traces for multi-exchange view
                    selectedExchanges.forEach((exchange, idx) => {
                        const exchangeData = data.data.filter(d => d.exchange === exchange);
                        const densities = prices.map(price =>
                            times.map(time => {
                                const point = exchangeData.find(d => d.time === time && d.price_bucket === price);
                                return point ? point.density : 0;
                            })
                        );

                        traces.push({
                            z: densities,
                            x: times,
                            y: prices,
                            type: 'heatmap',
                            name: exchange.charAt(0).toUpperCase() + exchange.slice(1),
                            colorscale: getExchangeColorscale(exchange),
                            opacity: 0.8,
                            // T080: Exchange-specific hovertemplate
                            hovertemplate: `Exchange: ${exchange}<br>Time: %{x}<br>Price: $%{y}<br>Density: %{z:.2f}<extra></extra>`
                        });
                    });

                    // T079: Show legend when multiple exchanges
                    document.getElementById('exchangeLegend').style.display = 'flex';
                } else {
                    // Single exchange or aggregated view
                    const densities = prices.map(price =>
                        times.map(time => {
                            const point = data.data.find(d => d.time === time && d.price_bucket === price);
                            return point ? point.density : 0;
                        })
                    );

                    const exchange = selectedExchanges[0] || 'all';
                    traces.push({
                        z: densities,
                        x: times,
                        y: prices,
                        type: 'heatmap',
                        colorscale: getExchangeColorscale(exchange),
                        // T080: Updated hovertemplate with exchange info
                        hovertemplate: `Time: %{x}<br>Price: $%{y}<br>Density: %{z:.2f}<extra></extra>`
                    });

                    document.getElementById('exchangeLegend').style.display = 'none';
                }

                // Add current price line if available
                const shapes = data.current_price ? [{
                    type: 'line',
                    x0: times[0],
                    x1: times[times.length - 1],
                    y0: data.current_price,
                    y1: data.current_price,
                    line: {
                        color: '#e74c3c',
                        width: 2,
                        dash: 'dash'
                    }
                }] : [];

                const exchangeLabel = exchanges === 'all' ? 'All Exchanges' :
                    selectedExchanges.map(e => e.charAt(0).toUpperCase() + e.slice(1)).join(' + ');

                const layout = {
                    title: `Liquidation Heatmap - ${data.symbol} (${exchangeLabel})`,
                    xaxis: { title: 'Time' },
                    yaxis: { title: 'Price (USDT)' },
                    paper_bgcolor: '#0d1117',
                    plot_bgcolor: '#161b22',
                    font: { color: '#c9d1d9' },
                    shapes: shapes
                };

                Plotly.newPlot('heatmap', traces, layout);
                hideLoading();  // T072

            } catch (error) {
                hideLoading();  // T072
                console.error('Error loading heatmap:', error);
                alert('Error loading heatmap. Check console for details.');
            }
        }

        // T077: Get colorscale based on exchange
        function getExchangeColorscale(exchange) {
            const baseColor = EXCHANGE_COLORS[exchange] || EXCHANGE_COLORS.all;
            return [
                [0, '#1a1a2e'],
                [0.25, adjustBrightness(baseColor, -40)],
                [0.5, adjustBrightness(baseColor, -20)],
                [0.75, baseColor],
                [1, adjustBrightness(baseColor, 20)]
            ];
        }

        // Helper: Adjust color brightness
        function adjustBrightness(hex, percent) {
            const num = parseInt(hex.replace('#', ''), 16);
            const amt = Math.round(2.55 * percent);
            const R = Math.min(255, Math.max(0, (num >> 16) + amt));
            const G = Math.min(255, Math.max(0, (num >> 8 & 0x00FF) + amt));
            const B = Math.min(255, Math.max(0, (num & 0x0000FF) + amt));
            return '#' + (0x1000000 + R * 0x10000 + G * 0x100 + B).toString(16).slice(1);
        }

        // T074/T075: Fetch and update exchange health badges
        async function updateExchangeHealth() {
            try {
                const response = await fetch('http://localhost:8000/exchanges/health');
                const healthData = await response.json();

                // Update badges for each exchange
                Object.entries(healthData).forEach(([exchange, health]) => {
                    const statusDot = document.getElementById(`${exchange}-status`);
                    const heartbeatSpan = document.getElementById(`${exchange}-heartbeat`);

                    if (statusDot) {
                        // T075: Update status dot color
                        statusDot.classList.remove('connected', 'disconnected', 'degraded');
                        if (health.is_connected) {
                            statusDot.classList.add(health.error_count > 0 ? 'degraded' : 'connected');
                        } else {
                            statusDot.classList.add('disconnected');
                        }
                    }

                    if (heartbeatSpan && health.last_heartbeat) {
                        // Show relative time since last heartbeat
                        const lastBeat = new Date(health.last_heartbeat);
                        const now = new Date();
                        const diffSec = Math.floor((now - lastBeat) / 1000);
                        if (diffSec < 60) {
                            heartbeatSpan.textContent = `${diffSec}s ago`;
                        } else if (diffSec < 3600) {
                            heartbeatSpan.textContent = `${Math.floor(diffSec / 60)}m ago`;
                        } else {
                            heartbeatSpan.textContent = `${Math.floor(diffSec / 3600)}h ago`;
                        }
                    }
                });
            } catch (error) {
                console.warn('Failed to fetch exchange health:', error);
                // Don't alert on health check failures - non-critical
            }
        }

        // T074: Start health polling on page load
        function startHealthPolling() {
            // Initial fetch
            updateExchangeHealth();

            // Poll every 30 seconds
            healthPollInterval = setInterval(updateExchangeHealth, HEALTH_POLL_INTERVAL_MS);
        }

        // Cluster state
        let clustersVisible = false;
        let clusterData = null;
        let autoRefreshInterval = null;
        const REFRESH_INTERVAL_MS = 5000; // T039: 5 second polling

        // Start health polling on page load
        document.addEventListener('DOMContentLoaded', startHealthPolling);

        // T029: Toggle clusters on/off
        async function toggleClusters() {
            const button = document.getElementById('clusterToggle');

            if (!clustersVisible) {
                // Show clusters
                await fetchAndShowClusters();
                button.textContent = 'Hide Clusters';
                clustersVisible = true;

                // T039: Start auto-refresh
                startAutoRefresh();
            } else {
                // Hide clusters - reload original heatmap
                await loadHeatmap();
                document.getElementById('clusterInfo').style.display = 'none';
                button.textContent = 'Show Clusters';
                clustersVisible = false;

                // T039: Stop auto-refresh
                stopAutoRefresh();
            }
        }

        // T039: Auto-refresh with polling
        function startAutoRefresh() {
            if (autoRefreshInterval) {
                clearInterval(autoRefreshInterval);
            }

            autoRefreshInterval = setInterval(async () => {
                if (clustersVisible) {
                    await refreshClustersWithDiff();
                }
            }, REFRESH_INTERVAL_MS);
        }

        function stopAutoRefresh() {
            if (autoRefreshInterval) {
                clearInterval(autoRefreshInterval);
                autoRefreshInterval = null;
            }
        }

        // T039: Refresh clusters and detect changes (diff)
        async function refreshClustersWithDiff() {
            try {
                const response = await fetch('http://localhost:8000/api/liquidations/clusters?symbol=BTCUSDT&timeframe_minutes=30&auto_tune=true');
                const newData = await response.json();

                if (!clusterData) {
                    clusterData = newData;
                    renderClustersOnHeatmap(newData);
                    return;
                }

                // T039: Detect cluster diff
                const oldClusterCount = clusterData.clusters.length;
                const newClusterCount = newData.clusters.length;

                if (oldClusterCount !== newClusterCount) {
                    // T038: Smooth transition - fade out old, fade in new
                    clusterData = newData;
                    renderClustersOnHeatmap(newData);
                }

            } catch (error) {
                console.error('Auto-refresh error:', error);
                // Don't alert on background refresh errors
            }
        }

        // T030: Fetch clusters from API and display
        async function fetchAndShowClusters() {
            try {
                const response = await fetch('http://localhost:8000/api/liquidations/clusters?symbol=BTCUSDT&timeframe_minutes=30&auto_tune=true');
                const data = await response.json();

                if (!data.clusters || data.clusters.length === 0) {
                    alert('No clusters found. Try adjusting parameters.');
                    return;
                }

                clusterData = data;
                renderClustersOnHeatmap(data);

            } catch (error) {
                console.error('Error fetching clusters:', error);
                alert('Error fetching clusters. Make sure API is running on port 8000.');
            }
        }

        // T031, T032: Render cluster zones as Plotly shapes with color gradient
        function renderClustersOnHeatmap(data) {
            const heatmapDiv = document.getElementById('heatmap');

            // Get current plot data
            const currentData = heatmapDiv.data;
            const currentLayout = heatmapDiv.layout;

            // T032: Calculate color gradient based on total_volume
            const maxVolume = Math.max(...data.clusters.map(c => c.total_volume));

            // T031: Create rectangle shapes for each cluster
            const clusterShapes = data.clusters.map((cluster, idx) => {
                // T032: Color intensity based on volume (red gradient)
                const volumeRatio = cluster.total_volume / maxVolume;
                const redIntensity = Math.floor(120 + (volumeRatio * 135)); // 120-255
                const color = `rgba(${redIntensity}, 50, 50, 0.3)`;
                const borderColor = `rgba(${redIntensity}, 50, 50, 0.8)`;

                return {
                    type: 'rect',
                    xref: 'paper', // Full width
                    x0: 0,
                    x1: 1,
                    yref: 'y',
                    y0: cluster.price_min,
                    y1: cluster.price_max,
                    fillcolor: color,
                    line: {
                        color: borderColor,
                        width: 2
                    },
                    // T033: Click handler data
                    layer: 'below',
                    name: `cluster_${cluster.cluster_id}`
                };
            });

            // Combine with existing shapes (current price line)
            const allShapes = [...(currentLayout.shapes || []), ...clusterShapes];

            // Update layout with cluster shapes
            const newLayout = {
                ...currentLayout,
                shapes: allShapes,
                title: `Liquidation Heatmap - ${data.metadata.symbol} (${data.clusters.length} clusters)`
            };

            // Re-plot with clusters
            Plotly.react('heatmap', currentData, newLayout);

            // T033: Add click handler for cluster details
            heatmapDiv.on('plotly_click', function(eventData) {
                const yValue = eventData.points[0].y;
                showClusterDetails(yValue, data);
            });
        }

        // T033: Show cluster details on click
        function showClusterDetails(priceLevel, data) {
            // Find cluster containing this price level
            const cluster = data.clusters.find(c =>
                priceLevel >= c.price_min && priceLevel <= c.price_max
            );

            if (!cluster) {
                return; // Clicked outside cluster zones
            }

            const detailsDiv = document.getElementById('clusterDetails');
            const infoDiv = document.getElementById('clusterInfo');

            detailsDiv.innerHTML = `
                <p><strong>Cluster ID:</strong> ${cluster.cluster_id}</p>
                <p><strong>Price Range:</strong> $${cluster.price_min.toFixed(2)} - $${cluster.price_max.toFixed(2)}</p>
                <p><strong>Price Spread:</strong> $${cluster.price_spread.toFixed(2)}</p>
                <p><strong>Centroid Price:</strong> $${cluster.centroid_price.toFixed(2)}</p>
                <p><strong>Total Volume:</strong> ${(cluster.total_volume / 1e6).toFixed(2)}M USDT</p>
                <p><strong>Level Count:</strong> ${cluster.level_count} liquidation levels</p>
                <p><strong>Avg Volume/Level:</strong> ${(cluster.avg_volume_per_level / 1e6).toFixed(2)}M USDT</p>
                <p><strong>Density:</strong> ${(cluster.density * 100).toFixed(1)}%</p>
                <p><strong>Zone Strength:</strong> <span style="color: ${
                    cluster.zone_strength === 'critical' ? '#e74c3c' :
                    cluster.zone_strength === 'significant' ? '#f39c12' : '#3498db'
                }">${cluster.zone_strength.toUpperCase()}</span></p>
            `;

            infoDiv.style.display = 'block';
        }
    </script>
</body>
</html>
