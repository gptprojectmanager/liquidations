<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BTC/USDT Liquidation Heatmap</title>
    <script src="https://cdn.plot.ly/plotly-2.26.0.min.js"></script>
    <link rel="stylesheet" href="styles.css">
    <style>
        /* T038: Smooth CSS transitions for cluster zones (60 FPS, <300ms) */
        .cluster-zone {
            transition: opacity 250ms ease-out, transform 250ms ease-out;
            will-change: opacity, transform;
        }
        .cluster-zone-enter {
            opacity: 0;
            transform: scaleY(0.95);
        }
        .cluster-zone-exit {
            opacity: 0;
            transform: scaleY(1.05);
        }
    </style>
</head>
<body>
    <h1>BTC/USDT Liquidation Heatmap</h1>
    <div class="controls">
        <button onclick="loadHeatmap()">Load Heatmap</button>
        <button id="clusterToggle" onclick="toggleClusters()" style="margin-left: 10px;">Show Clusters</button>
    </div>
    <div id="heatmap"></div>
    <div id="clusterInfo" style="margin-top: 20px; padding: 10px; background: #161b22; border-radius: 6px; display: none;">
        <h3>Cluster Details</h3>
        <div id="clusterDetails"></div>
    </div>

    <script>
        async function loadHeatmap() {
            try {
                const response = await fetch('http://localhost:8000/liquidations/heatmap?symbol=BTCUSDT&model=binance_standard');
                const data = await response.json();
                
                if (!data.data || data.data.length === 0) {
                    alert('No heatmap data available. Run: python scripts/generate_heatmap_cache.py');
                    return;
                }
                
                // Extract unique times and prices
                const times = [...new Set(data.data.map(d => d.time))].sort();
                const prices = [...new Set(data.data.map(d => d.price_bucket))].sort((a, b) => a - b);
                
                // Build 2D density matrix
                const densities = prices.map(price => 
                    times.map(time => {
                        const point = data.data.find(d => d.time === time && d.price_bucket === price);
                        return point ? point.density : 0;
                    })
                );
                
                // Plotly heatmap
                const trace = {
                    z: densities,
                    x: times,
                    y: prices,
                    type: 'heatmap',
                    colorscale: [
                        [0, '#1a1a2e'],
                        [0.25, '#9b59b6'],
                        [0.5, '#3498db'],
                        [0.75, '#1abc9c'],
                        [1, '#f0b90b']
                    ],
                    hovertemplate: 'Time: %{x}<br>Price: $%{y}<br>Density: %{z}<extra></extra>'
                };
                
                // Add current price line if available
                const shapes = data.current_price ? [{
                    type: 'line',
                    x0: times[0],
                    x1: times[times.length - 1],
                    y0: data.current_price,
                    y1: data.current_price,
                    line: {
                        color: '#e74c3c',
                        width: 2,
                        dash: 'dash'
                    }
                }] : [];
                
                const layout = {
                    title: `Liquidation Heatmap - ${data.symbol}`,
                    xaxis: { title: 'Time' },
                    yaxis: { title: 'Price (USDT)' },
                    paper_bgcolor: '#0d1117',
                    plot_bgcolor: '#161b22',
                    font: { color: '#c9d1d9' },
                    shapes: shapes
                };
                
                Plotly.newPlot('heatmap', [trace], layout);
                
            } catch (error) {
                console.error('Error loading heatmap:', error);
                alert('Error loading heatmap. Check console for details.');
            }
        }

        // Cluster state
        let clustersVisible = false;
        let clusterData = null;
        let autoRefreshInterval = null;
        const REFRESH_INTERVAL_MS = 5000; // T039: 5 second polling

        // T029: Toggle clusters on/off
        async function toggleClusters() {
            const button = document.getElementById('clusterToggle');

            if (!clustersVisible) {
                // Show clusters
                await fetchAndShowClusters();
                button.textContent = 'Hide Clusters';
                clustersVisible = true;

                // T039: Start auto-refresh
                startAutoRefresh();
            } else {
                // Hide clusters - reload original heatmap
                await loadHeatmap();
                document.getElementById('clusterInfo').style.display = 'none';
                button.textContent = 'Show Clusters';
                clustersVisible = false;

                // T039: Stop auto-refresh
                stopAutoRefresh();
            }
        }

        // T039: Auto-refresh with polling
        function startAutoRefresh() {
            if (autoRefreshInterval) {
                clearInterval(autoRefreshInterval);
            }

            autoRefreshInterval = setInterval(async () => {
                if (clustersVisible) {
                    await refreshClustersWithDiff();
                }
            }, REFRESH_INTERVAL_MS);
        }

        function stopAutoRefresh() {
            if (autoRefreshInterval) {
                clearInterval(autoRefreshInterval);
                autoRefreshInterval = null;
            }
        }

        // T039: Refresh clusters and detect changes (diff)
        async function refreshClustersWithDiff() {
            try {
                const response = await fetch('http://localhost:8000/api/liquidations/clusters?symbol=BTCUSDT&timeframe_minutes=30&auto_tune=true');
                const newData = await response.json();

                if (!clusterData) {
                    clusterData = newData;
                    renderClustersOnHeatmap(newData);
                    return;
                }

                // T039: Detect cluster diff
                const oldClusterCount = clusterData.clusters.length;
                const newClusterCount = newData.clusters.length;

                if (oldClusterCount !== newClusterCount) {
                    // T038: Smooth transition - fade out old, fade in new
                    clusterData = newData;
                    renderClustersOnHeatmap(newData);
                }

            } catch (error) {
                console.error('Auto-refresh error:', error);
                // Don't alert on background refresh errors
            }
        }

        // T030: Fetch clusters from API and display
        async function fetchAndShowClusters() {
            try {
                const response = await fetch('http://localhost:8000/api/liquidations/clusters?symbol=BTCUSDT&timeframe_minutes=30&auto_tune=true');
                const data = await response.json();

                if (!data.clusters || data.clusters.length === 0) {
                    alert('No clusters found. Try adjusting parameters.');
                    return;
                }

                clusterData = data;
                renderClustersOnHeatmap(data);

            } catch (error) {
                console.error('Error fetching clusters:', error);
                alert('Error fetching clusters. Make sure API is running on port 8000.');
            }
        }

        // T031, T032: Render cluster zones as Plotly shapes with color gradient
        function renderClustersOnHeatmap(data) {
            const heatmapDiv = document.getElementById('heatmap');

            // Get current plot data
            const currentData = heatmapDiv.data;
            const currentLayout = heatmapDiv.layout;

            // T032: Calculate color gradient based on total_volume
            const maxVolume = Math.max(...data.clusters.map(c => c.total_volume));

            // T031: Create rectangle shapes for each cluster
            const clusterShapes = data.clusters.map((cluster, idx) => {
                // T032: Color intensity based on volume (red gradient)
                const volumeRatio = cluster.total_volume / maxVolume;
                const redIntensity = Math.floor(120 + (volumeRatio * 135)); // 120-255
                const color = `rgba(${redIntensity}, 50, 50, 0.3)`;
                const borderColor = `rgba(${redIntensity}, 50, 50, 0.8)`;

                return {
                    type: 'rect',
                    xref: 'paper', // Full width
                    x0: 0,
                    x1: 1,
                    yref: 'y',
                    y0: cluster.price_min,
                    y1: cluster.price_max,
                    fillcolor: color,
                    line: {
                        color: borderColor,
                        width: 2
                    },
                    // T033: Click handler data
                    layer: 'below',
                    name: `cluster_${cluster.cluster_id}`
                };
            });

            // Combine with existing shapes (current price line)
            const allShapes = [...(currentLayout.shapes || []), ...clusterShapes];

            // Update layout with cluster shapes
            const newLayout = {
                ...currentLayout,
                shapes: allShapes,
                title: `Liquidation Heatmap - ${data.metadata.symbol} (${data.clusters.length} clusters)`
            };

            // Re-plot with clusters
            Plotly.react('heatmap', currentData, newLayout);

            // T033: Add click handler for cluster details
            heatmapDiv.on('plotly_click', function(eventData) {
                const yValue = eventData.points[0].y;
                showClusterDetails(yValue, data);
            });
        }

        // T033: Show cluster details on click
        function showClusterDetails(priceLevel, data) {
            // Find cluster containing this price level
            const cluster = data.clusters.find(c =>
                priceLevel >= c.price_min && priceLevel <= c.price_max
            );

            if (!cluster) {
                return; // Clicked outside cluster zones
            }

            const detailsDiv = document.getElementById('clusterDetails');
            const infoDiv = document.getElementById('clusterInfo');

            detailsDiv.innerHTML = `
                <p><strong>Cluster ID:</strong> ${cluster.cluster_id}</p>
                <p><strong>Price Range:</strong> $${cluster.price_min.toFixed(2)} - $${cluster.price_max.toFixed(2)}</p>
                <p><strong>Price Spread:</strong> $${cluster.price_spread.toFixed(2)}</p>
                <p><strong>Centroid Price:</strong> $${cluster.centroid_price.toFixed(2)}</p>
                <p><strong>Total Volume:</strong> ${(cluster.total_volume / 1e6).toFixed(2)}M USDT</p>
                <p><strong>Level Count:</strong> ${cluster.level_count} liquidation levels</p>
                <p><strong>Avg Volume/Level:</strong> ${(cluster.avg_volume_per_level / 1e6).toFixed(2)}M USDT</p>
                <p><strong>Density:</strong> ${(cluster.density * 100).toFixed(1)}%</p>
                <p><strong>Zone Strength:</strong> <span style="color: ${
                    cluster.zone_strength === 'critical' ? '#e74c3c' :
                    cluster.zone_strength === 'significant' ? '#f39c12' : '#3498db'
                }">${cluster.zone_strength.toUpperCase()}</span></p>
            `;

            infoDiv.style.display = 'block';
        }
    </script>
</body>
</html>
