#!/usr/bin/env python3
"""Unified aggTrades ingestion orchestrator - FIXED VERSION."""

import argparse
import logging
import sys
from datetime import datetime
from pathlib import Path
from typing import List, Tuple

import duckdb

# Adjust path for imports
sys.path.insert(0, "/media/sam/1TB/LiquidationHeatmap")

from src.liquidationheatmap.ingestion.aggtrades_streaming import load_aggtrades_streaming

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class IngestionOrchestrator:
    """Unified orchestrator for complete aggTrades ingestion."""

    def __init__(self, symbol: str, data_dir: Path, db_path: Path, throttle_ms: int = 100):
        self.symbol = symbol
        self.data_dir = data_dir
        self.db_path = db_path
        self.throttle_ms = throttle_ms
        self.conn = None

    def connect(self):
        """Open database connection."""
        self.conn = duckdb.connect(str(self.db_path))
        logger.info(f"Connected to database: {self.db_path}")

    def close(self):
        """Close database connection."""
        if self.conn:
            self.conn.close()

    def discover_files(self) -> List[Path]:
        """Phase 1: Discover available CSV files."""
        aggtrades_dir = self.data_dir / self.symbol / "aggTrades"
        if not aggtrades_dir.exists():
            print(f"‚ùå Directory not found: {aggtrades_dir}")
            return []

        all_files = sorted(aggtrades_dir.glob(f"{self.symbol}-aggTrades-*.csv"))
        print(f"‚úÖ Found {len(all_files):,} CSV files")
        return all_files

    def detect_gaps(self) -> List[Tuple[str, str]]:
        """Phase 2: Detect missing date ranges in database."""
        result = self.conn.execute("""
            SELECT MIN(DATE(timestamp)), MAX(DATE(timestamp))
            FROM aggtrades_history
        """).fetchone()

        if not result[0]:
            print("‚ö†Ô∏è  Empty database - full ingestion needed")
            return []

        min_date, max_date = result

        gaps_query = f"""
            WITH RECURSIVE date_series AS (
                SELECT DATE '{min_date}' as expected_date
                UNION ALL
                SELECT expected_date + INTERVAL 1 DAY
                FROM date_series
                WHERE expected_date < DATE '{max_date}'
            ),
            actual_dates AS (
                SELECT DISTINCT DATE(timestamp) as actual_date
                FROM aggtrades_history
            )
            SELECT d.expected_date
            FROM date_series d
            LEFT JOIN actual_dates a ON d.expected_date = a.actual_date
            WHERE a.actual_date IS NULL
            ORDER BY d.expected_date
        """

        missing_dates = [row[0] for row in self.conn.execute(gaps_query).fetchall()]

        if not missing_dates:
            print("‚úÖ No gaps detected")
            return []

        gaps = self._consolidate_gaps(missing_dates)
        print(f"‚ö†Ô∏è  Found {len(gaps)} gap(s)")
        for start, end in gaps:
            days = (end - start).days + 1
            print(f"   ‚Ä¢ {start} ‚Üí {end} ({days} days)")

        return gaps

    def _consolidate_gaps(self, missing_dates: List) -> List[Tuple[str, str]]:
        """Consolidate consecutive missing dates into ranges."""
        if not missing_dates:
            return []

        gaps = []
        range_start = missing_dates[0]
        prev_date = missing_dates[0]

        for current_date in missing_dates[1:]:
            if (current_date - prev_date).days > 1:
                gaps.append((str(range_start), str(prev_date)))
                range_start = current_date
            prev_date = current_date

        gaps.append((str(range_start), str(prev_date)))
        return gaps

    def fill_gaps(self, gaps: List[Tuple[str, str]], max_retries: int = 3) -> bool:
        """Phase 3: Fill detected gaps with retry logic."""
        if not gaps:
            return True

        success_count = 0
        fail_count = 0

        for idx, (start_date, end_date) in enumerate(gaps, 1):
            for attempt in range(1, max_retries + 1):
                try:
                    total_rows = load_aggtrades_streaming(
                        self.conn,
                        self.data_dir,
                        self.symbol,
                        start_date,
                        end_date,
                        throttle_ms=self.throttle_ms
                    )

                    print(f"‚úÖ Filled: {total_rows:,} rows")
                    success_count += 1
                    break

                except Exception as e:
                    if attempt < max_retries:
                        print(f"‚ö†Ô∏è  Attempt {attempt} failed: {e}")
                    else:
                        print(f"‚ùå Failed after {max_retries} attempts: {e}")
                        fail_count += 1

        print(f"\nüìä Gap filling summary: ‚úÖ {success_count}/{len(gaps)} ‚ùå {fail_count}/{len(gaps)}")
        return fail_count == 0

    def generate_report(self):
        """Phase 4: Generate final summary report."""
        stats = self.conn.execute("""
            SELECT
                COUNT(*) as total_rows,
                MIN(timestamp) as min_timestamp,
                MAX(timestamp) as max_timestamp,
                COUNT(DISTINCT DATE(timestamp)) as days_with_data,
                MIN(price) as min_price,
                MAX(price) as max_price,
                SUM(gross_value) as total_volume
            FROM aggtrades_history
        """).fetchone()

        total_rows, min_ts, max_ts, days, min_price, max_price, volume = stats

        print("=" * 70)
        print("  INGESTION SUMMARY")
        print("=" * 70)
        print(f"Total Rows:     {total_rows:,}")
        print(f"Date Range:     {min_ts} -> {max_ts}")
        print(f"Days with Data: {days:,}")
        print(f"Avg Rows/Day:   {total_rows // days:,}" if days > 0 else "Avg Rows/Day:   N/A")
        print(f"Price Range:    ${min_price:,.2f} - ${max_price:,.2f}")
        print(f"Total Volume:   ${volume:,.2f}")
        print("=" * 70)

    def run(self, mode: str = "auto") -> int:
        """Main orchestration logic."""
        try:
            print(f"\nüöÄ Unified Ingestion Orchestrator")
            print(f"Symbol: {self.symbol}")
            print(f"Mode: {mode}")
            print(f"Throttle: {self.throttle_ms}ms\n")

            # Connect to database
            self.connect()

            # Phase 1: Discovery
            print("üìÇ Phase 1: Discovery")
            files = self.discover_files()
            if not files:
                print("‚ùå No files found")
                return 1

            # Phase 2: Gap Detection
            print("\nüîç Phase 2: Gap Detection")
            gaps = self.detect_gaps()

            # Phase 3: Gap Filling
            if gaps:
                print(f"\nüîß Phase 3: Filling {len(gaps)} gap(s)")
                success = self.fill_gaps(gaps)
                if not success:
                    print("\n‚ùå Some gaps could not be filled")
                    return 1

            # Phase 4: Report
            print("\nüìä Phase 4: Final Report")
            self.generate_report()

            print("\n‚úÖ Orchestration complete!")
            return 0

        except Exception as e:
            logger.exception("Orchestration failed")
            print(f"\n‚ùå ERROR: {e}")
            return 1

        finally:
            self.close()


def main():
    parser = argparse.ArgumentParser(description="Unified aggTrades ingestion orchestrator")
    parser.add_argument("--symbol", default="BTCUSDT")
    parser.add_argument("--data-dir", required=True)
    parser.add_argument("--db", default="/media/sam/1TB/LiquidationHeatmap/data/processed/liquidations.duckdb")
    parser.add_argument("--mode", default="auto", choices=["auto", "dry-run"])
    parser.add_argument("--throttle-ms", type=int, default=100)

    args = parser.parse_args()

    orchestrator = IngestionOrchestrator(
        symbol=args.symbol,
        data_dir=Path(args.data_dir),
        db_path=Path(args.db),
        throttle_ms=args.throttle_ms
    )

    sys.exit(orchestrator.run(mode=args.mode))


if __name__ == "__main__":
    main()
